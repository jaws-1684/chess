#!/usr/bin/env ruby
# frozen_string_literal: true

require_relative '../lib/chess'

def name_prompt(message)
  print "Enter #{message} player's name:\s".colorize(:green)
  _name = gets.chomp.downcase
end

def color_prompt
  print "Enter first player's color [ white or black (w/b) ]!:\s".colorize(:green)
  color = gets.chomp.downcase.to_sym
  return color if %i[white black].include?(color)

  case color
  when :b then :black
  when :w then :white
  else
    puts 'Thats not a valid color try again! choose from [white or black]'
    color_prompt
  end
end

def switch_colors(player)
  player.color == :white ? :black : :white
end

def game
  a = Artii::Base.new
  puts 'Welcome to chess. Press Ctrl+C to exit'.colorize(:red)
  puts a.asciify('Chess')
  puts "\tDeveloped by: jaws".colorize(:blue)
  puts "\tGitHub: github.com/jaws-1684".colorize(:blue)
  puts "\tVersion: 1.1\n".colorize(:blue)
  puts "[Type 'save' to save the game, 'exit' to quit]"
  puts 'Options:'
  puts '  1. Start a new game'
  puts '  2. Load saved game'
  choice = gets.chomp

  if choice == '2' && Chess::Game.saved_games?
    game = Chess::Game.load_saved_game!(Chess::Game.saved_files)
    game.play
  else
    puts 'Starting a new game...'
    yield if block_given?
  end
rescue Interrupt
end

Player = Struct.new(:name, :color)

game do
  first_player = Player.new(name_prompt(:first), color_prompt)

  print "Do you wanna play with the computer?(y/n):\s".colorize(:red)
  answer = gets.chomp.downcase.to_sym
  second_player = if answer == :y
                    Chess::Computer.new(switch_colors(first_player))
                  else
                    Player.new(name_prompt(:second), switch_colors(first_player))
                  end
  # clearing the screen
  puts "\e[H\e[2J"

  Chess::Game.new(first_player, second_player).play
end
